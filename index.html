<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Tic-Tac-Toe Expert System</title>
		<!-- Bootstrap CSS -->
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
		<!-- Bootstrap Icons -->
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" />
		<!-- React and ReactDOM UMD builds -->
		<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
		<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
		<!-- Babel standalone to transpile JSX in the browser -->
		<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
		<style>
			body {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				min-height: 100vh;
				padding: 2rem 0;
			}
			.game-container {
				background: white;
				border-radius: 15px;
				box-shadow: 0 10px 40px rgba(0,0,0,0.2);
				padding: 2rem;
			}
			.board-cell {
				aspect-ratio: 1;
				font-size: 3.5rem;
				font-weight: bold;
				border: 3px solid #dee2e6;
				border-radius: 10px;
				transition: all 0.2s;
				user-select: none;
			}
			.board-cell:not(:disabled):hover {
				transform: scale(1.05);
				background-color: #f8f9fa !important;
			}
			.board-cell:disabled {
				cursor: not-allowed;
				opacity: 0.8;
			}
			.cell-x {
				background-color: #cfe2ff;
				color: #0d6efd;
				border-color: #0d6efd;
			}
			.cell-o {
				background-color: #f8d7da;
				color: #dc3545;
				border-color: #dc3545;
			}
			.cell-empty {
				background-color: #f8f9fa;
			}
			.cell-last-move {
				box-shadow: 0 0 0 4px #ffc107;
			}
			.rule-applied {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				border-radius: 10px;
				padding: 1rem;
				margin-bottom: 1.5rem;
			}
		</style>
	</head>
	<body>
		<div id="root" class="container"></div>

		<!-- Bootstrap JS Bundle -->
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

		<!-- App code: type text/babel so Babel transpiles JSX in-browser -->
		<script type="text/babel">
			const { useState, useEffect } = React;

			const TicTacToeAI = () => {
				const [board, setBoard] = useState(Array(9).fill(null));
				const [isPlayerTurn, setIsPlayerTurn] = useState(true);
				const [gameOver, setGameOver] = useState(false);
				const [winner, setWinner] = useState(null);
				const [scores, setScores] = useState({ player: 0, ai: 0, draws: 0 });
				const [lastMove, setLastMove] = useState(null);
				const [ruleApplied, setRuleApplied] = useState('');
				const [moveHistory, setMoveHistory] = useState([]);

				const checkWinner = (currentBoard) => {
					const lines = [
						[0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
						[0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
						[0, 4, 8], [2, 4, 6] // diagonals
					];

					for (const [a, b, c] of lines) {
						if (currentBoard[a] && currentBoard[a] === currentBoard[b] && currentBoard[a] === currentBoard[c]) {
							return currentBoard[a];
						}
					}
					return null;
				};

				// Enhanced Expert System Knowledge Base - Rules in priority order
				const expertSystem = {
					// Rule 1: WIN - If AI can win, take the winning move
					canWin: (board, player) => {
						for (let i = 0; i < 9; i++) {
							if (board[i] === null) {
								const testBoard = [...board];
								testBoard[i] = player;
								if (checkWinner(testBoard) === player) {
									return { move: i, rule: 'Win: Complete three-in-a-row' };
								}
							}
						}
						return null;
					},

					// Rule 2: BLOCK - If opponent can win, block them
					mustBlock: (board, player) => {
						const opponent = player === 'X' ? 'O' : 'X';
						for (let i = 0; i < 9; i++) {
							if (board[i] === null) {
								const testBoard = [...board];
								testBoard[i] = opponent;
								if (checkWinner(testBoard) === opponent) {
									return { move: i, rule: "Block: Prevent opponent's three-in-a-row" };
								}
							}
						}
						return null;
					},

					// Rule 3: FORK - Create two winning opportunities
					createFork: (board, player) => {
						for (let i = 0; i < 9; i++) {
							if (board[i] === null) {
								const testBoard = [...board];
								testBoard[i] = player;
								let winningMoves = 0;
								for (let j = 0; j < 9; j++) {
									if (testBoard[j] === null) {
										const testBoard2 = [...testBoard];
										testBoard2[j] = player;
										if (checkWinner(testBoard2) === player) {
											winningMoves++;
										}
									}
								}
								if (winningMoves >= 2) {
									return { move: i, rule: 'Fork: Create two winning opportunities' };
								}
							}
						}
						return null;
					},

					// Rule 4: BLOCK FORK - Prevent opponent from creating a fork
					blockFork: (board, player) => {
						const opponent = player === 'X' ? 'O' : 'X';
						const forks = [];
						
						// Find all positions where opponent could create a fork
						for (let i = 0; i < 9; i++) {
							if (board[i] === null) {
								const testBoard = [...board];
								testBoard[i] = opponent;
								let winningMoves = 0;
								for (let j = 0; j < 9; j++) {
									if (testBoard[j] === null) {
										const testBoard2 = [...testBoard];
										testBoard2[j] = opponent;
										if (checkWinner(testBoard2) === opponent) {
											winningMoves++;
										}
									}
								}
								if (winningMoves >= 2) {
									forks.push(i);
								}
							}
						}
						
						// If opponent has fork opportunities, try to block by forcing them to block us
						if (forks.length > 0) {
							// Try to create our own threat to force them to block instead
							for (let i = 0; i < 9; i++) {
								if (board[i] === null && !forks.includes(i)) {
									const testBoard = [...board];
									testBoard[i] = player;
									// Check if this move creates a winning opportunity for us
									for (let j = 0; j < 9; j++) {
										if (testBoard[j] === null) {
											const testBoard2 = [...testBoard];
											testBoard2[j] = player;
											if (checkWinner(testBoard2) === player) {
												return { move: i, rule: "Block Fork: Force opponent to block instead" };
											}
										}
									}
								}
							}
							// If we can't force a block, take one of the fork positions
							return { move: forks[0], rule: "Block Fork: Prevent opponent's fork" };
						}
						return null;
					},

					// Rule 5: CENTER - Take the center if available
					takeCenter: (board) => {
						if (board[4] === null) {
							return { move: 4, rule: 'Center: Control the middle position' };
						}
						return null;
					},

					// Rule 6: OPPOSITE CORNER - If opponent has a corner, take opposite corner
					takeOppositeCorner: (board, player) => {
						const opponent = player === 'X' ? 'O' : 'X';
						const cornerPairs = [[0, 8], [2, 6]];
						for (const [corner1, corner2] of cornerPairs) {
							if (board[corner1] === opponent && board[corner2] === null) {
								return { move: corner2, rule: "Opposite Corner: Counter opponent's corner" };
							}
							if (board[corner2] === opponent && board[corner1] === null) {
								return { move: corner1, rule: "Opposite Corner: Counter opponent's corner" };
							}
						}
						return null;
					},

					// Rule 7: EMPTY CORNER - Take any available corner
					takeCorner: (board) => {
						const corners = [0, 2, 6, 8];
						for (const corner of corners) {
							if (board[corner] === null) {
								return { move: corner, rule: 'Corner: Strong strategic position' };
							}
						}
						return null;
					},

					// Rule 8: EMPTY SIDE - Take any available side position
					takeSide: (board) => {
						const sides = [1, 3, 5, 7];
						for (const side of sides) {
							if (board[side] === null) {
								return { move: side, rule: 'Side: Available position' };
							}
						}
						return null;
					}
				};

				const getAIMove = (currentBoard) => {
					const rules = [
						expertSystem.canWin,
						expertSystem.mustBlock,
						expertSystem.createFork,
						expertSystem.blockFork,
						expertSystem.takeCenter,
						expertSystem.takeOppositeCorner,
						expertSystem.takeCorner,
						expertSystem.takeSide
					];

					for (const rule of rules) {
						const result = rule(currentBoard, 'O');
						if (result && currentBoard[result.move] === null) {
							return result;
						}
					}

					// Fallback: take first available position
					const fallback = currentBoard.findIndex(c => c === null);
					return { move: fallback === -1 ? 0 : fallback, rule: 'Default move' };
				};

				useEffect(() => {
					if (!isPlayerTurn && !gameOver) {
						const timer = setTimeout(() => {
							const { move, rule } = getAIMove(board);
							const newBoard = [...board];
							
							if (newBoard[move] === null) {
								newBoard[move] = 'O';
								setLastMove(move);
								setBoard(newBoard);
								setRuleApplied(rule);
								setMoveHistory(prev => [...prev, { move, player: 'O', rule }]);

								const gameWinner = checkWinner(newBoard);
								if (gameWinner) {
									setWinner(gameWinner);
									setGameOver(true);
									setScores(prev => ({ ...prev, ai: prev.ai + 1 }));
								} else if (newBoard.every(cell => cell !== null)) {
									setGameOver(true);
									setScores(prev => ({ ...prev, draws: prev.draws + 1 }));
								} else {
									setIsPlayerTurn(true);
								}
							}
						}, 600);
						return () => clearTimeout(timer);
					}
				}, [isPlayerTurn, board, gameOver]);

				const handleClick = (index) => {
					if (board[index] || !isPlayerTurn || gameOver) return;

					const newBoard = [...board];
					newBoard[index] = 'X';
					setBoard(newBoard);
					setLastMove(index);
					setRuleApplied('');
					setMoveHistory(prev => [...prev, { move: index, player: 'X' }]);

					const gameWinner = checkWinner(newBoard);
					if (gameWinner) {
						setWinner(gameWinner);
						setGameOver(true);
						setScores(prev => ({ ...prev, player: prev.player + 1 }));
					} else if (newBoard.every(cell => cell !== null)) {
						setGameOver(true);
						setScores(prev => ({ ...prev, draws: prev.draws + 1 }));
					} else {
						setIsPlayerTurn(false);
					}
				};

				const resetGame = () => {
					setBoard(Array(9).fill(null));
					setIsPlayerTurn(true);
					setGameOver(false);
					setWinner(null);
					setLastMove(null);
					setRuleApplied('');
					setMoveHistory([]);
				};

				const getCellClass = (index, cell) => {
					let classes = 'board-cell ';
					if (cell === 'X') classes += 'cell-x';
					else if (cell === 'O') classes += 'cell-o';
					else classes += 'cell-empty';
					if (lastMove === index) classes += ' cell-last-move';
					return classes;
				};

				return (
					<div className="game-container">
						<div className="text-center mb-4">
							<h1 className="display-4 fw-bold mb-2">
								<i className="bi bi-cpu"></i> Tic-Tac-Toe Expert System
							</h1>
							<p className="lead text-muted">Challenge the AI powered by rule-based reasoning</p>
						</div>

						<div className="row g-3 mb-4">
							<div className="col-4">
								<div className="card border-primary border-2">
									<div className="card-body text-center">
										<h2 className="display-6 fw-bold text-primary">{scores.player}</h2>
										<p className="mb-0 text-muted">You (X)</p>
									</div>
								</div>
							</div>
							<div className="col-4">
								<div className="card border-secondary border-2">
									<div className="card-body text-center">
										<h2 className="display-6 fw-bold text-secondary">{scores.draws}</h2>
										<p className="mb-0 text-muted">Draws</p>
									</div>
								</div>
							</div>
							<div className="col-4">
								<div className="card border-danger border-2">
									<div className="card-body text-center">
										<h2 className="display-6 fw-bold text-danger">{scores.ai}</h2>
										<p className="mb-0 text-muted">AI (O)</p>
									</div>
								</div>
							</div>
						</div>

						{ruleApplied && (
							<div className="rule-applied">
								<div className="d-flex align-items-center mb-2">
									<i className="bi bi-lightbulb-fill me-2 fs-4"></i>
									<strong>AI Rule Applied:</strong>
								</div>
								<p className="mb-0">{ruleApplied}</p>
							</div>
						)}

						<div className="card shadow-lg mb-4">
							<div className="card-body p-4">
								<div className="row g-3 mb-4">
									{board.map((cell, index) => (
										<div key={index} className="col-4">
											<button
												onClick={() => handleClick(index)}
												disabled={!isPlayerTurn || gameOver || cell !== null}
												className={getCellClass(index, cell) + ' w-100'}
											>
												{cell || ''}
											</button>
										</div>
									))}
								</div>

								<div className="text-center">
									{gameOver ? (
										<div className="alert alert-info mb-0" role="alert">
											<i className="bi bi-trophy-fill me-2"></i>
											<strong className="fs-4">
												{winner ? (winner === 'X' ? 'You Win!' : 'AI Wins!') : "It's a Draw!"}
											</strong>
										</div>
									) : (
										<p className="fs-5 fw-semibold text-muted mb-0">
											{isPlayerTurn ? (
												<><i className="bi bi-person-circle me-2"></i>Your Turn (X)</>
											) : (
												<><i className="bi bi-hourglass-split me-2"></i>AI is thinking...</>
											)}
										</p>
									)}
								</div>
							</div>
						</div>

						<button
							onClick={resetGame}
							className="btn btn-primary btn-lg w-100 mb-4"
						>
							<i className="bi bi-arrow-clockwise me-2"></i>
							New Game
						</button>

						<div className="card">
							<div className="card-header bg-primary text-white">
								<h5 className="mb-0">
									<i className="bi bi-list-ol me-2"></i>
									Expert System Rules (Priority Order)
								</h5>
							</div>
							<div className="card-body">
								<ol className="mb-0">
									<li className="mb-2"><strong>Win:</strong> Complete three-in-a-row if possible</li>
									<li className="mb-2"><strong>Block:</strong> Prevent opponent's three-in-a-row</li>
									<li className="mb-2"><strong>Fork:</strong> Create two winning opportunities</li>
									<li className="mb-2"><strong>Block Fork:</strong> Prevent opponent's fork (with advanced counter-strategy)</li>
									<li className="mb-2"><strong>Center:</strong> Take the center position</li>
									<li className="mb-2"><strong>Opposite Corner:</strong> Counter opponent's corner</li>
									<li className="mb-2"><strong>Corner:</strong> Take any available corner</li>
									<li><strong>Side:</strong> Take any available side</li>
								</ol>
							</div>
						</div>
					</div>
				);
			};

			// Mount app
			const root = ReactDOM.createRoot(document.getElementById('root'));
			root.render(<TicTacToeAI />);
		</script>
	</body>
</html>
